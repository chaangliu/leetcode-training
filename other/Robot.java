package other;

import java.util.HashSet;

/**
 * åŠ›æ‰£å›¢é˜Ÿä¹°äº†ä¸€ä¸ªå¯ç¼–ç¨‹æœºå™¨äººï¼Œæœºå™¨äººåˆå§‹ä½ç½®åœ¨åŸç‚¹(0, 0)ã€‚å°ä¼™ä¼´äº‹å…ˆç»™æœºå™¨äººè¾“å…¥ä¸€ä¸²æŒ‡ä»¤commandï¼Œæœºå™¨äººå°±ä¼šæ— é™å¾ªç¯è¿™æ¡æŒ‡ä»¤çš„æ­¥éª¤è¿›è¡Œç§»åŠ¨ã€‚æŒ‡ä»¤æœ‰ä¸¤ç§ï¼š
 * <p>
 * U: å‘yè½´æ­£æ–¹å‘ç§»åŠ¨ä¸€æ ¼
 * R: å‘xè½´æ­£æ–¹å‘ç§»åŠ¨ä¸€æ ¼ã€‚
 * ä¸å¹¸çš„æ˜¯ï¼Œåœ¨ xy å¹³é¢ä¸Šè¿˜æœ‰ä¸€äº›éšœç¢ç‰©ï¼Œä»–ä»¬çš„åæ ‡ç”¨obstaclesè¡¨ç¤ºã€‚æœºå™¨äººä¸€æ—¦ç¢°åˆ°éšœç¢ç‰©å°±ä¼šè¢«æŸæ¯ã€‚
 * <p>
 * ç»™å®šç»ˆç‚¹åæ ‡(x, y)ï¼Œè¿”å›æœºå™¨äººèƒ½å¦å®Œå¥½åœ°åˆ°è¾¾ç»ˆç‚¹ã€‚å¦‚æœèƒ½ï¼Œè¿”å›trueï¼›å¦åˆ™è¿”å›falseã€‚
 * ç¤ºä¾‹ 1ï¼š
 * <p>
 * è¾“å…¥ï¼šcommand = "URR", obstacles = [], x = 3, y = 2
 * è¾“å‡ºï¼štrue
 * è§£é‡Šï¼šU(0, 1) -> R(1, 1) -> R(2, 1) -> U(2, 2) -> R(3, 2)ã€‚
 * ç¤ºä¾‹ 2ï¼š
 * <p>
 * è¾“å…¥ï¼šcommand = "URR", obstacles = [[2, 2]], x = 3, y = 2
 * è¾“å‡ºï¼šfalse
 * è§£é‡Šï¼šæœºå™¨äººåœ¨åˆ°è¾¾ç»ˆç‚¹å‰ä¼šç¢°åˆ°(2, 2)çš„éšœç¢ç‰©ã€‚
 * ç¤ºä¾‹ 3ï¼š
 * <p>
 * è¾“å…¥ï¼šcommand = "URR", obstacles = [[4, 2]], x = 3, y = 2
 * è¾“å‡ºï¼štrue
 * è§£é‡Šï¼šåˆ°è¾¾ç»ˆç‚¹åï¼Œå†ç¢°åˆ°éšœç¢ç‰©ä¹Ÿä¸å½±å“è¿”å›ç»“æœã€‚
 * <p>
 * <p>
 * é™åˆ¶ï¼š
 * <p>
 * 2 <= commandçš„é•¿åº¦ <= 1000
 * commandç”±Uï¼ŒRæ„æˆï¼Œä¸”è‡³å°‘æœ‰ä¸€ä¸ªUï¼Œè‡³å°‘æœ‰ä¸€ä¸ªR
 * 0 <= x <= 1e9, 0 <= y <= 1e9
 * 0 <= obstaclesçš„é•¿åº¦ <= 1000
 * obstacles[i]ä¸ä¸ºåŸç‚¹æˆ–è€…ç»ˆç‚¹
 * 20190924ï¼ŒåŠ›æ‰£ç§‹å­£èµ›ç¬¬ä¸‰é¢˜
 */
public class Robot {
    /**
     * è¿™é¢˜ä¹Ÿæ˜¯æ¨¡æ‹Ÿé¢˜ï¼Œæˆ‘ä¸€å¼€å§‹æƒ³æŠŠæ‰€æœ‰è·¯å¾„éƒ½æ¨¡æ‹Ÿä¸€éï¼Œæœç„¶è¶…æ—¶ï¼›
     * ç„¶åå‘ç°ä¸€æ¬¡commandä¹‹åé‡å¤çš„è·¯å¾„éƒ½å¯ä»¥ç”±å…¬å¼ç®—å‡ºæ¥ï¼Œæ€è·¯å¯¹çš„ã€‚
     * ä¸è¿‡å¿˜è®°ç®—å…¥("0#0")äº†ï¼Œæµªè´¹äº†å¾ˆå¤šæ—¶é—´ã€‚ã€‚
     * <p>
     * ç§‹å­£èµ›ç¬¬å››ç¬¬äº”é¢˜éƒ½æ˜¯hardï¼Œæˆ‘å°±å…ˆäº¤å·äº†ğŸ˜„
     */
    public boolean robot(String command, int[][] obstacles, int x, int y) {
        int[] path = new int[]{0, 0};
        HashSet<String> dots = new HashSet<>();
        dots.add("0#0");
        for (int i = 0; i < command.length(); i++) {
            if (command.charAt(i) == 'U') path[1]++;
            else path[0]++;
            dots.add(path[0] + "#" + path[1]);
        }
        for (int[] o : obstacles) {
            if (o[0] > x || o[1] > y) continue;
            int div = o[0] / path[0];
            String key = (o[0] - div * path[0]) + "#" + (o[1] - div * path[1]);
            if (dots.contains(key))
                return false;
        }
        int div = x / path[0];
        return dots.contains((x - div * path[0]) + "#" + (y - div * path[1]));
    }
}
